use std::{collections::VecDeque, marker::PhantomData};

use chain_utils::{
    ethereum::{EthereumConsensusChain, EthereumIbcChain, EthereumIbcChainExt, IbcHandlerExt},
    scroll::Scroll,
};
use ethers::{abi::AbiDecode, providers::Middleware};
use frunk::{hlist_pat, HList};
use queue_msg::{
    aggregate,
    aggregation::{do_aggregate, UseAggregate},
    data, effect, fetch, queue_msg, Op,
};
use scroll_codec::{FinalizeBundle, FinalizeBundleWithProof};
use unionlabs::{
    encoding::{Decode, Encode, EthAbi},
    hash::{H160, H256},
    ibc::{
        core::client::msg_update_client::MsgUpdateClient,
        lightclients::{
            ethereum::{account_proof::AccountProof, storage_proof::StorageProof},
            scroll,
        },
    },
    ics24::ClientStatePath,
    never::Never,
    traits::{Chain, ClientStateOf, HeightOf, IbcStateEncodingOf},
    uint::U256,
};

use crate::{
    aggregate::{Aggregate, AnyAggregate},
    chain::ethereum::{
        do_msg, fetch_get_proof, fetch_ibc_state, EthereumConfig, FetchIbcState, GetProof,
        TxSubmitError,
    },
    data::{AnyData, Data},
    effect::{AnyEffect, Effect, MsgUpdateClientData},
    fetch::{AnyFetch, DoFetch, Fetch, FetchUpdateHeaders},
    id, identified,
    use_aggregate::IsAggregateData,
    AnyLightClientIdentified, ChainExt, DoAggregate, DoFetchProof, DoFetchState,
    DoFetchUpdateHeaders, DoMsg, Identified, PathOf, RelayMessage,
};

impl ChainExt for Scroll {
    type Data<Tr: ChainExt> = ScrollData<Tr>;
    type Fetch<Tr: ChainExt> = ScrollFetch<Tr>;
    type Aggregate<Tr: ChainExt> = ScrollAggregate<Tr>;

    type MsgError = TxSubmitError;

    type Config = EthereumConfig;
}

impl<Tr> DoMsg<Self, Tr> for Scroll
where
    ClientStateOf<Scroll>: Encode<Tr::IbcStateEncoding>,
    Tr: ChainExt<
        SelfConsensusState: Encode<EthAbi>,
        SelfClientState: Encode<EthAbi>,
        Header: Encode<EthAbi>,
        StoredClientState<Scroll>: Encode<Tr::IbcStateEncoding>,
        StateProof: Encode<EthAbi>,
    >,
    AnyLightClientIdentified<AnyEffect>: From<identified!(Effect<Self, Tr>)>,
{
    async fn msg(&self, msg: Effect<Self, Tr>) -> Result<Op<RelayMessage>, Self::MsgError> {
        do_msg(
            self.chain_id(),
            self.multicall_address,
            &self.keyring,
            msg,
            true,
            None,
        )
        .await
    }
}

impl<Tr: ChainExt> DoFetchProof<Self, Tr> for Scroll
where
    AnyLightClientIdentified<AnyFetch>: From<identified!(Fetch<Scroll, Tr>)>,
{
    fn proof(c: &Self, at: HeightOf<Self>, path: PathOf<Scroll, Tr>) -> Op<RelayMessage> {
        fetch(id::<Self, Tr, _>(
            c.chain_id(),
            Fetch::<Self, Tr>::specific(GetProof { path, height: at }),
        ))
    }
}

// REVIEW: This can probably be generic over Hc: EthereumChain, instead of being duplicated between ethereum and scroll
impl<Tr> DoFetchState<Self, Tr> for Scroll
where
    Tr: ChainExt<SelfClientState: Decode<IbcStateEncodingOf<Scroll>> + Encode<EthAbi>>,

    AnyLightClientIdentified<AnyFetch>: From<identified!(Fetch<Scroll, Tr>)>,
{
    type QueryUnfinalizedTrustedClientStateError = Never;

    fn state(hc: &Self, at: HeightOf<Self>, path: PathOf<Self, Tr>) -> Op<RelayMessage> {
        fetch(id::<Self, Tr, _>(
            hc.chain_id(),
            Fetch::<Self, Tr>::specific(FetchIbcState { path, height: at }),
        ))
    }

    async fn query_unfinalized_trusted_client_state(
        hc: &Self,
        client_id: Self::ClientId,
    ) -> Result<Self::StoredClientState<Tr>, Self::QueryUnfinalizedTrustedClientStateError> {
        let latest_execution_height = hc.provider.get_block_number().await.unwrap().as_u64();

        Ok(hc
            .ibc_handler()
            .ibc_state_read::<_, Self, Tr>(latest_execution_height, ClientStatePath { client_id })
            .await
            .unwrap())
    }
}

impl<Tr> DoFetchUpdateHeaders<Self, Tr> for Scroll
where
    AnyLightClientIdentified<AnyFetch>: From<identified!(Fetch<Scroll, Tr>)>,
    AnyLightClientIdentified<AnyAggregate>: From<identified!(Aggregate<Scroll, Tr>)>,
    Tr: ChainExt,
{
    fn fetch_update_headers(
        c: &Self,
        update_info: FetchUpdateHeaders<Self, Tr>,
    ) -> Op<RelayMessage> {
        // - scroll rollup contract root proof
        // - scroll latest batch index proof against rollup contract
        // - scroll finalized root at batch index against rollup contract
        // - ibc contract root against finalized root on L2
        // - commitBatch calldata and popped messages to verify timestamp

        aggregate(
            [
                fetch(id(
                    c.chain_id(),
                    Fetch::specific(FetchRollupContractRootProof {
                        height: update_info.update_to,
                        rollup_contract_address: c.rollup_contract_address,
                    }),
                )),
                fetch(id(
                    c.chain_id(),
                    Fetch::specific(FetchLatestBatchIndexProof {
                        height: update_info.update_to,
                        latest_batch_index_slot: c.rollup_last_finalized_batch_index_slot,
                        rollup_contract_address: c.rollup_contract_address,
                    }),
                )),
                fetch(id(
                    c.chain_id(),
                    Fetch::specific(FetchScrollFinalizedRootProof {
                        height: update_info.update_to,
                        finalized_root_slot: c.rollup_finalized_state_roots_slot,
                        rollup_contract_address: c.rollup_contract_address,
                    }),
                )),
                fetch(id(
                    c.chain_id(),
                    Fetch::specific(FetchIbcContractRootProof {
                        height: update_info.update_to,
                        ibc_contract_address: c.ibc_handler_address,
                    }),
                )),
                fetch(id(
                    c.chain_id(),
                    Fetch::specific(FetchBatchHashProof {
                        height: update_info.update_to,
                        committed_batches_slot: c.rollup_committed_batches_slot,
                        rollup_contract_address: c.rollup_contract_address,
                    }),
                )),
                fetch(id(
                    c.chain_id(),
                    Fetch::specific(FetchFinalizeBatchTransactionInput {
                        height: update_info.update_to,
                        rollup_contract_address: c.rollup_contract_address,
                    }),
                )),
            ],
            [],
            id(
                c.chain_id(),
                Aggregate::<Scroll, Tr>::specific(AggregateHeader { req: update_info }),
            ),
        )
    }
}

impl<Tr> DoFetch<Scroll> for ScrollFetch<Tr>
where
    AnyLightClientIdentified<AnyData>: From<identified!(Data<Scroll, Tr>)>,
    Tr: ChainExt<
        SelfClientState: Decode<IbcStateEncodingOf<Scroll>>,
        SelfConsensusState: Decode<IbcStateEncodingOf<Scroll>> + Encode<EthAbi>,
    >,
{
    type Error = Never;

    async fn do_fetch(scroll: &Scroll, msg: Self) -> Result<Op<RelayMessage>, Self::Error> {
        let msg = match msg {
            Self::FetchGetProof(get_proof) => fetch_get_proof(scroll, get_proof).await,
            Self::FetchIbcState(ibc_state) => fetch_ibc_state(scroll, ibc_state).await,
            Self::FetchRollupContractRootProof(FetchRollupContractRootProof {
                height,
                rollup_contract_address,
            }) => {
                let account_proof = scroll
                    .l1
                    .provider()
                    .get_proof(
                        ethers::types::H160::from(rollup_contract_address),
                        vec![],
                        Some(ethers::types::BlockId::Number(
                            scroll
                                .l1
                                .execution_height_of_beacon_slot(height.revision_height)
                                .await
                                .into(),
                        )),
                    )
                    .await
                    .unwrap();

                Data::specific(RollupContractRootProof {
                    height,
                    proof: AccountProof {
                        storage_root: account_proof.storage_hash.into(),
                        proof: account_proof
                            .account_proof
                            .into_iter()
                            .map(|x| x.to_vec())
                            .collect(),
                    },
                    __marker: PhantomData,
                })
            }
            Self::FetchLatestBatchIndexProof(FetchLatestBatchIndexProof {
                height,
                latest_batch_index_slot,
                rollup_contract_address,
            }) => {
                let latest_batch_index_proof = scroll
                    .l1
                    .provider
                    .get_proof(
                        ethers::types::H160::from(rollup_contract_address),
                        vec![H256(latest_batch_index_slot.to_be_bytes()).into()],
                        Some(ethers::types::BlockId::Number(
                            scroll
                                .l1
                                .execution_height_of_beacon_slot(height.revision_height)
                                .await
                                .into(),
                        )),
                    )
                    .await
                    .unwrap();

                let proof = match <[_; 1]>::try_from(latest_batch_index_proof.storage_proof) {
                    Ok([proof]) => proof,
                    Err(invalid) => {
                        panic!("received invalid response from eth_getProof, expected length of 1 but got `{invalid:#?}`");
                    }
                };

                Data::specific(LatestBatchIndexProof {
                    height,
                    proof: StorageProof {
                        key: U256::from_be_bytes(proof.key.to_fixed_bytes()),
                        value: proof.value.into(),
                        proof: proof
                            .proof
                            .into_iter()
                            .map(|bytes| bytes.to_vec())
                            .collect(),
                    },
                    __marker: PhantomData,
                })
            }
            Self::FetchScrollFinalizedRootProof(FetchScrollFinalizedRootProof {
                height,
                finalized_root_slot,
                rollup_contract_address,
            }) => {
                let batch_index = scroll
                    .batch_index_of_beacon_slot(height.revision_height)
                    .await;

                let batch_hash_proof = scroll
                    .l1
                    .provider
                    .get_proof(
                        ethers::types::H160::from(rollup_contract_address),
                        vec![H256(
                            scroll_verifier::mapping_index_to_slot_key(
                                finalized_root_slot,
                                batch_index.into(),
                            )
                            .to_be_bytes(),
                        )
                        .into()],
                        Some(ethers::types::BlockId::Number(
                            scroll
                                .l1
                                .execution_height_of_beacon_slot(height.revision_height)
                                .await
                                .into(),
                        )),
                    )
                    .await
                    .unwrap();

                let proof = match <[_; 1]>::try_from(batch_hash_proof.storage_proof) {
                    Ok([proof]) => proof,
                    Err(invalid) => {
                        panic!("received invalid response from eth_getProof, expected length of 1 but got `{invalid:#?}`");
                    }
                };

                Data::specific(ScrollFinalizedRootProof {
                    height,
                    batch_index,
                    proof: StorageProof {
                        key: U256::from_be_bytes(proof.key.to_fixed_bytes()),
                        value: proof.value.into(),
                        proof: proof
                            .proof
                            .into_iter()
                            .map(|bytes| bytes.to_vec())
                            .collect(),
                    },
                    __marker: PhantomData,
                })
            }
            Self::FetchIbcContractRootProof(FetchIbcContractRootProof {
                height,
                ibc_contract_address,
            }) => {
                let batch_index = scroll
                    .batch_index_of_beacon_slot(height.revision_height)
                    .await;

                let batch = scroll.scroll_api_client.batch(batch_index).await;

                let proof = scroll
                    .scroll_rpc
                    .get_proof(
                        ibc_contract_address,
                        [],
                        scroll_rpc::BlockId::Number(batch.batch.end_block_number),
                    )
                    .await
                    .unwrap();

                Data::specific(IbcContractRootProof {
                    height,
                    proof: AccountProof {
                        storage_root: proof.storage_hash,
                        proof: proof
                            .account_proof
                            .into_iter()
                            .map(|x| x.to_vec())
                            .collect(),
                    },
                    __marker: PhantomData,
                })
            }
            Self::FetchBatchHashProof(FetchBatchHashProof {
                height,
                committed_batches_slot,
                rollup_contract_address,
            }) => {
                let batch_index = scroll
                    .batch_index_of_beacon_slot(height.revision_height)
                    .await;

                let batch_hash_proof = scroll
                    .l1
                    .provider
                    .get_proof(
                        ethers::types::H160::from(rollup_contract_address),
                        vec![H256(
                            scroll_verifier::mapping_index_to_slot_key(
                                committed_batches_slot,
                                batch_index.into(),
                            )
                            .to_be_bytes(),
                        )
                        .into()],
                        Some(ethers::types::BlockId::Number(
                            scroll
                                .l1
                                .execution_height_of_beacon_slot(height.revision_height)
                                .await
                                .into(),
                        )),
                    )
                    .await
                    .unwrap();

                let proof = match <[_; 1]>::try_from(batch_hash_proof.storage_proof) {
                    Ok([proof]) => proof,
                    Err(invalid) => {
                        panic!("received invalid response from eth_getProof, expected length of 1 but got `{invalid:#?}`");
                    }
                };

                Data::specific(BatchHashProof {
                    height,
                    batch_index,
                    proof: StorageProof {
                        key: U256::from_be_bytes(proof.key.to_fixed_bytes()),
                        value: proof.value.into(),
                        proof: proof
                            .proof
                            .into_iter()
                            .map(|bytes| bytes.to_vec())
                            .collect(),
                    },
                    __marker: PhantomData,
                })
            }
            ScrollFetch::FetchFinalizeBatchTransactionInput(
                FetchFinalizeBatchTransactionInput {
                    height,
                    // TODO: This needs to be passed to `scroll_codec::fetch_l1_message_hashes`
                    rollup_contract_address: _,
                },
            ) => {
                let batch_index = scroll
                    .batch_index_of_beacon_slot(height.revision_height)
                    .await;

                let batch = scroll.scroll_api_client.batch(batch_index).await;

                let finalize_batch_tx = scroll
                    .l1
                    .provider
                    .get_transaction(
                        batch
                            .batch
                            .finalize_tx_hash
                            .expect("batch must be finalized"),
                    )
                    .await
                    .unwrap()
                    .unwrap();

                let calldata = finalize_batch_tx.input.to_vec();

                let batch_header = <FinalizeBundleWithProof as AbiDecode>::decode(&calldata)
                    .map(|call| call.batch_header)
                    .or_else(|_| {
                        <FinalizeBundle as AbiDecode>::decode(&calldata)
                            .map(|call| call.batch_header)
                    })
                    .unwrap()
                    .to_vec();

                Data::specific(FinalizeBatchTransactionInput {
                    height,
                    batch_index,
                    batch_header,
                    __marker: PhantomData,
                })
            }
        };

        Ok(data(id::<Scroll, Tr, _>(scroll.chain_id, msg)))
    }
}

#[queue_msg]
#[derive(enumorph::Enumorph)]
pub enum ScrollFetch<Tr: ChainExt> {
    FetchGetProof(GetProof<Scroll, Tr>),
    FetchIbcState(FetchIbcState<Scroll, Tr>),

    // - scroll rollup contract root proof
    FetchRollupContractRootProof(FetchRollupContractRootProof),
    // - scroll latest batch index proof against rollup contract
    FetchLatestBatchIndexProof(FetchLatestBatchIndexProof),
    // - scroll finalized root at batch index against rollup contract
    FetchScrollFinalizedRootProof(FetchScrollFinalizedRootProof),
    // - ibc contract root against finalized root on L2
    FetchIbcContractRootProof(FetchIbcContractRootProof),
    FetchBatchHashProof(FetchBatchHashProof),
    FetchFinalizeBatchTransactionInput(FetchFinalizeBatchTransactionInput),
}

#[queue_msg]
pub struct FetchRollupContractRootProof {
    // the height to update to
    pub height: HeightOf<Scroll>,
    pub rollup_contract_address: H160,
}

#[queue_msg]
pub struct FetchLatestBatchIndexProof {
    // the height to update to
    pub height: HeightOf<Scroll>,
    pub latest_batch_index_slot: U256,
    pub rollup_contract_address: H160,
}

#[queue_msg]
pub struct FetchBatchHashProof {
    pub height: HeightOf<Scroll>,
    pub committed_batches_slot: U256,
    pub rollup_contract_address: H160,
}

#[queue_msg]
pub struct FetchScrollFinalizedRootProof {
    // the height to update to
    pub height: HeightOf<Scroll>,
    pub finalized_root_slot: U256,
    pub rollup_contract_address: H160,
}

#[queue_msg]
pub struct FetchFinalizeBatchTransactionInput {
    // the height to update to
    pub height: HeightOf<Scroll>,
    pub rollup_contract_address: H160,
}

#[queue_msg]
pub struct FetchIbcContractRootProof {
    // the height to update to
    pub height: HeightOf<Scroll>,
    pub ibc_contract_address: H160,
}

#[queue_msg]
#[derive(enumorph::Enumorph)]
pub enum ScrollData<Tr: ChainExt> {
    RollupContractRootProof(RollupContractRootProof<Tr>),
    LatestBatchIndexProof(LatestBatchIndexProof<Tr>),
    ScrollFinalizedRootProof(ScrollFinalizedRootProof<Tr>),
    IbcContractRootProof(IbcContractRootProof<Tr>),
    BatchHashProof(BatchHashProof<Tr>),
    FinalizeBatchTransactionInput(FinalizeBatchTransactionInput<Tr>),
}

try_from_relayer_msg! {
    chain = Scroll,
    generics = (Tr: ChainExt),
    msgs = ScrollData(
        RollupContractRootProof(RollupContractRootProof<Tr>),
        LatestBatchIndexProof(LatestBatchIndexProof<Tr>),
        ScrollFinalizedRootProof(ScrollFinalizedRootProof<Tr>),
        IbcContractRootProof(IbcContractRootProof<Tr>),
        BatchHashProof(BatchHashProof<Tr>),
        FinalizeBatchTransactionInput(FinalizeBatchTransactionInput<Tr>),
    ),
}

#[queue_msg]
pub struct RollupContractRootProof<#[cover] Tr: ChainExt> {
    pub height: HeightOf<Scroll>,
    pub proof: AccountProof,
}

#[queue_msg]
pub struct LatestBatchIndexProof<#[cover] Tr: ChainExt> {
    pub height: HeightOf<Scroll>,
    pub proof: StorageProof,
}

#[queue_msg]
pub struct BatchHashProof<#[cover] Tr: ChainExt> {
    pub height: HeightOf<Scroll>,
    pub batch_index: u64,
    pub proof: StorageProof,
}

#[queue_msg]
pub struct ScrollFinalizedRootProof<#[cover] Tr: ChainExt> {
    pub height: HeightOf<Scroll>,
    pub batch_index: u64,
    pub proof: StorageProof,
}

#[queue_msg]
pub struct IbcContractRootProof<#[cover] Tr: ChainExt> {
    pub height: HeightOf<Scroll>,
    pub proof: AccountProof,
}

#[queue_msg]
pub struct FinalizeBatchTransactionInput<#[cover] Tr: ChainExt> {
    pub height: HeightOf<Scroll>,
    pub batch_index: u64,
    #[serde(with = "::serde_utils::hex_string")]
    #[debug(wrap = ::serde_utils::fmt::DebugAsHex)]
    pub batch_header: Vec<u8>,
}

#[queue_msg]
#[derive(enumorph::Enumorph)]
pub enum ScrollAggregate<Tr: ChainExt> {
    AggregateHeader(AggregateHeader<Tr>),
}

#[queue_msg]
pub struct AggregateHeader<Tr: ChainExt> {
    pub req: FetchUpdateHeaders<Scroll, Tr>,
}

impl<Tr: ChainExt> DoAggregate for Identified<Scroll, Tr, ScrollAggregate<Tr>>
where
    Identified<Scroll, Tr, RollupContractRootProof<Tr>>: IsAggregateData,
    Identified<Scroll, Tr, LatestBatchIndexProof<Tr>>: IsAggregateData,
    Identified<Scroll, Tr, ScrollFinalizedRootProof<Tr>>: IsAggregateData,
    Identified<Scroll, Tr, IbcContractRootProof<Tr>>: IsAggregateData,
    Identified<Scroll, Tr, BatchHashProof<Tr>>: IsAggregateData,
    Identified<Scroll, Tr, FinalizeBatchTransactionInput<Tr>>: IsAggregateData,

    AnyLightClientIdentified<AnyEffect>: From<identified!(Effect<Tr, Scroll>)>,
    AnyLightClientIdentified<AnyData>: From<identified!(Data<Scroll, Tr>)>,
{
    fn do_aggregate(
        Identified {
            chain_id,
            t,
            __marker,
        }: Self,
        data: VecDeque<AnyLightClientIdentified<AnyData>>,
    ) -> Op<RelayMessage> {
        match t {
            ScrollAggregate::AggregateHeader(msg) => do_aggregate(id(chain_id, msg), data),
        }
    }
}

impl<Tr> UseAggregate<RelayMessage> for Identified<Scroll, Tr, AggregateHeader<Tr>>
where
    Tr: ChainExt,
    Identified<Scroll, Tr, RollupContractRootProof<Tr>>: IsAggregateData,
    Identified<Scroll, Tr, LatestBatchIndexProof<Tr>>: IsAggregateData,
    Identified<Scroll, Tr, ScrollFinalizedRootProof<Tr>>: IsAggregateData,
    Identified<Scroll, Tr, IbcContractRootProof<Tr>>: IsAggregateData,
    Identified<Scroll, Tr, BatchHashProof<Tr>>: IsAggregateData,
    Identified<Scroll, Tr, FinalizeBatchTransactionInput<Tr>>: IsAggregateData,

    AnyLightClientIdentified<AnyEffect>: From<identified!(Effect<Tr, Scroll>)>,
{
    type AggregatedData = HList![
        Identified<Scroll, Tr, RollupContractRootProof<Tr>>,
        Identified<Scroll, Tr, LatestBatchIndexProof<Tr>>,
        Identified<Scroll, Tr, ScrollFinalizedRootProof<Tr>>,
        Identified<Scroll, Tr, IbcContractRootProof<Tr>>,
        Identified<Scroll, Tr, BatchHashProof<Tr>>,
        Identified<Scroll, Tr, FinalizeBatchTransactionInput<Tr>>,
    ];

    fn aggregate(
        Identified {
            chain_id,
            t: AggregateHeader { req },
            __marker: _,
        }: Self,
        hlist_pat![
            Identified {
                chain_id: rollup_contract_root_proof_chain_id,
                t: RollupContractRootProof {
                    height: rollup_contract_root_proof_height,
                    proof: rollup_contract_root_proof,
                    __marker: _
                },
                __marker: _,
            },
            Identified {
                chain_id: latest_batch_index_proof_chain_id,
                t: LatestBatchIndexProof {
                    height: latest_batch_index_proof_height,
                    proof: latest_batch_index_proof,
                    __marker: _
                },
                __marker: _,
            },
            Identified {
                chain_id: scroll_finalized_root_proof_chain_id,
                t: ScrollFinalizedRootProof {
                    height: scroll_finalized_root_proof_height,
                    batch_index: scroll_finalized_root_proof_batch_index,
                    proof: scroll_finalized_root_proof,
                    __marker: _
                },
                __marker: _,
            },
            Identified {
                chain_id: ibc_contract_root_proof_chain_id,
                t: IbcContractRootProof {
                    height: ibc_contract_root_proof_height,
                    proof: ibc_contract_account_proof,
                    __marker: _
                },
                __marker: _,
            },
            Identified {
                chain_id: batch_hash_proof_chain_id,
                t: BatchHashProof {
                    height: batch_hash_proof_height,
                    batch_index: batch_hash_proof_batch_index,
                    proof: batch_hash_proof,
                    __marker: _,
                },
                __marker: _,
            },
            Identified {
                chain_id: finalize_batch_transaction_input_chain_id,
                t: FinalizeBatchTransactionInput {
                    height: finalize_batch_transaction_input_height,
                    batch_index: finalize_batch_transaction_input_batch_index,
                    batch_header,
                    __marker,
                },
                __marker: _,
            }
        ]: Self::AggregatedData,
    ) -> Op<RelayMessage> {
        assert_eq!(rollup_contract_root_proof_chain_id, chain_id);
        assert_eq!(latest_batch_index_proof_chain_id, chain_id);
        assert_eq!(scroll_finalized_root_proof_chain_id, chain_id);
        assert_eq!(ibc_contract_root_proof_chain_id, chain_id);
        assert_eq!(batch_hash_proof_chain_id, chain_id);
        assert_eq!(finalize_batch_transaction_input_chain_id, chain_id);

        assert_eq!(
            rollup_contract_root_proof_height,
            latest_batch_index_proof_height
        );
        assert_eq!(
            rollup_contract_root_proof_height,
            scroll_finalized_root_proof_height
        );
        assert_eq!(
            rollup_contract_root_proof_height,
            ibc_contract_root_proof_height
        );
        assert_eq!(rollup_contract_root_proof_height, batch_hash_proof_height);
        assert_eq!(
            rollup_contract_root_proof_height,
            finalize_batch_transaction_input_height
        );

        assert_eq!(
            scroll_finalized_root_proof_batch_index,
            batch_hash_proof_batch_index
        );
        assert_eq!(
            scroll_finalized_root_proof_batch_index,
            finalize_batch_transaction_input_batch_index
        );

        effect(id::<Tr, Scroll, _>(
            req.counterparty_chain_id,
            MsgUpdateClientData(MsgUpdateClient {
                client_id: req.counterparty_client_id,
                client_message: scroll::header::Header {
                    l1_height: req.update_to,
                    l1_account_proof: rollup_contract_root_proof,
                    l2_state_root_proof: scroll_finalized_root_proof,
                    last_batch_index_proof: latest_batch_index_proof,
                    l2_ibc_account_proof: ibc_contract_account_proof,
                    batch_hash_proof,
                    batch_header,
                },
            }),
        ))
    }
}
