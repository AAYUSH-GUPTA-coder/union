syntax = "proto3";
package union.ibc.lightclients.movement.v1;

option go_package = "union/ibc/lightclients/movement";
import "ibc/core/client/v1/client.proto";
import "union/ibc/lightclients/ethereum/v1/ethereum.proto";

message ClientState {
  bytes l1_contract_address = 1;
  bytes l2_contract_address = 2;
  bytes table_handle = 3;
  .ibc.core.client.v1.Height frozen_height = 4;
  uint64 latest_block_num = 5;
}

message ConsensusState {
  // Aptos state root
  bytes state_root = 1;
  // Movement timestamp
  uint64 timestamp = 2;
  // Hash of the `StateProof` which is committed to l1
  bytes state_proof_hash = 3;
}

message Header {
  .ibc.core.client.v1.Height l1_height = 1;
  .ibc.core.client.v1.Height trusted_height = 2;
  StateProof state_proof = 3;
}

message StateProof {
  LedgerInfoWithSignatures latest_li_w_sigs = 1;
  EpochChangeProof epoch_changes = 2;
}

message LedgerInfoWithSignatures {
  LedgerInfo ledger_info = 1;
  /// Aggregated BLS signature of all the validators that signed the message. The bitmask in the
  /// aggregated signature can be used to find out the individual validators signing the message
  AggregateSignature signatures = 2;
}

message LedgerInfo {
  BlockInfo commit_info = 1;
  bytes consensus_data_hash = 2;
}

message BlockInfo {
  uint64 epoch = 1;
  uint64 round = 2;
  bytes id = 3;
  bytes executed_state_id = 4;
  uint64 version = 5;
  uint64 timestamp_usecs = 6;
  EpochState next_epoch_state = 7;
}

message EpochState {
  uint64 epoch = 1;
  ValidatorVerifier verifier = 2;
}

message ValidatorVerifier {
  repeated ValidatorConsensusInfo validator_infos = 1;
}

message ValidatorConsensusInfo {
  bytes address = 1;
  PublicKey public_key = 2;
  uint64 voting_power = 3;
}

message PublicKey {
  bytes pubkey = 1;
}

message AggregateSignature {
  bytes validator_bitmask = 1;
  Signature sig = 2;
}

message Signature {
  bytes sig = 1;
}

message EpochChangeProof {
  repeated LedgerInfoWithSignatures ledger_info_with_sigs = 1;
  bool more = 2;
}
