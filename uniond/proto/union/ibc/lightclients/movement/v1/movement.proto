syntax = "proto3";
package union.ibc.lightclients.movement.v1;

option go_package = "union/ibc/lightclients/movement";
import "ibc/core/client/v1/client.proto";
import "union/ibc/lightclients/ethereum/v1/ethereum.proto";

message ClientState {
  bytes l1_contract_address = 1;
  bytes l2_contract_address = 2;
  bytes table_handle = 3;
  .ibc.core.client.v1.Height frozen_height = 4;
}

message ConsensusState {
  // Aptos state root
  bytes state_root = 1;
  // Movement timestamp
  uint64 timestamp = 2;
  // Hash of the `StateProof` which is committed to l1
  bytes state_proof_hash = 3;
}

message Header {
  StateProof state_proof = 1;
}

message StateProof {
  LedgerInfoWithSignatures latest_li_w_sigs = 1;
  EpochChangeProof epoch_changes = 2;
}

message LedgerInfoWithSignatures {
  LedgerInfo ledger_info = 1;
  /// Aggregated BLS signature of all the validators that signed the message. The bitmask in the
  /// aggregated signature can be used to find out the individual validators signing the message
  AggregateSignature signatures = 2;
}

message LedgerInfo {
  BlockInfo commit_info = 1;
  bytes consensus_data_hash = 2;
}

message BlockInfo {
  uint64 epoch = 1;
  uint64 round = 2;
  bytes id = 3;
  bytes executed_state_id = 4;
  uint64 version = 5;
  uint64 timestamp_usecs = 6;
  EpochState next_epoch_state = 7;
}

message EpochState {
  uint64 epoch = 1;
  ValidatorVerifier verifier = 2;
}

message ValidatorVerifier {
  repeated ValidatorConsensusInfo validator_infos = 1;
}

message ValidatorConsensusInfo {
  bytes address = 1;
  PublicKey public_key = 2;
  uint64 voting_power = 3;
}

message PublicKey {
  bytes pubkey = 1;
}

message AggregateSignature {
  bytes validator_bitmask = 1;
  Signature sig = 2;
}

message Signature {
  bytes sig = 1;
}

message EpochChangeProof {
  repeated LedgerInfoWithSignatures ledger_info_with_sigs = 1;
  bool more = 2;
}

// message Header {
//   .ibc.core.client.v1.Height l1_height = 1;
//   // rollupContractOnL1 ∈ L1Stateroot
//   .union.ibc.lightclients.ethereum.v1.AccountProof l1_account_proof = 2;
//   // lastBatchIndex ≡ rollupContractOnL1.lastBatchIndex
//   .union.ibc.lightclients.ethereum.v1.StorageProof last_batch_index_proof = 3;
//   // L2stateRoot ≡ rollupContractOnL1.finalized[lastBatchIndex]
//   .union.ibc.lightclients.ethereum.v1.StorageProof l2_state_root_proof = 4;
//   // ibcContractOnL2 ∈ L2StateRoot
//   .union.ibc.lightclients.ethereum.v1.AccountProof l2_ibc_account_proof = 5;
//   // batchHash ≡ rollupContractOnL1.batchHashes[lastBatchIndex]
//   .union.ibc.lightclients.ethereum.v1.StorageProof batch_hash_proof = 6;
//   // The batch header from where we extract the L2 timestamp, then proving:
//   // hash(batchHeader) ≡ batchHash
//   bytes batch_header = 7;
// }

