syntax = "proto3";
package union.ibc.lightclients.movement.v1;

option go_package = "union/ibc/lightclients/movement";
import "ibc/core/client/v1/client.proto";
import "union/ibc/lightclients/ethereum/v1/ethereum.proto";

message ClientState {
  bytes l1_contract_address = 1;
  bytes l2_contract_address = 2;
  bytes table_handle = 3;
  .ibc.core.client.v1.Height frozen_height = 4;
}

// message ConsensusState {
//   // Scroll state root
//   bytes state_root = 1;
//   // Scroll timestamp
//   uint64 timestamp = 2;
//   // IBC stack on Scroll contract storage root
//   bytes ibc_storage_root = 3;
// }

// message Header {
//   .ibc.core.client.v1.Height l1_height = 1;
//   // rollupContractOnL1 ∈ L1Stateroot
//   .union.ibc.lightclients.ethereum.v1.AccountProof l1_account_proof = 2;
//   // lastBatchIndex ≡ rollupContractOnL1.lastBatchIndex
//   .union.ibc.lightclients.ethereum.v1.StorageProof last_batch_index_proof = 3;
//   // L2stateRoot ≡ rollupContractOnL1.finalized[lastBatchIndex]
//   .union.ibc.lightclients.ethereum.v1.StorageProof l2_state_root_proof = 4;
//   // ibcContractOnL2 ∈ L2StateRoot
//   .union.ibc.lightclients.ethereum.v1.AccountProof l2_ibc_account_proof = 5;
//   // batchHash ≡ rollupContractOnL1.batchHashes[lastBatchIndex]
//   .union.ibc.lightclients.ethereum.v1.StorageProof batch_hash_proof = 6;
//   // The batch header from where we extract the L2 timestamp, then proving:
//   // hash(batchHeader) ≡ batchHash
//   bytes batch_header = 7;
// }

